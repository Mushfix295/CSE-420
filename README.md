# CSE-420
Compiler Design

ðŸ“˜ Assignment 1 â€“ Lexical and Syntax Analyzer using Flex & Bison
This assignment implements the front-end stages of a compiler, specifically lexical analysis and syntax analysis, for a C-like programming language using Flex and Bison. The lexical analyzer (scanner) identifies tokens such as keywords, identifiers, operators, literals, and punctuation using regular expression patterns and passes them to the parser. The syntax analyzer (parser) validates the token stream according to a formally defined context-free grammar and performs shift-reduce parsing to construct syntactic structures. Grammar rules define constructs such as variable declarations, expressions, statements, and control structures. A basic SymbolInfo structure is used to store token attributes like lexeme and type, primarily to facilitate parsing and logging. This assignment focuses on correct tokenization, grammar rule implementation, operator precedence handling, and structured parse tracing, forming the foundational components of a compilerâ€™s front-end without advanced semantic or scope management.

ðŸ“— Assignment 2 â€“ Scope-Aware Symbol Table and Semantic Analysis
This assignment extends the previous work into a more complete compiler front-end by integrating semantic analysis and a hierarchical symbol table with scope management. In addition to lexical and syntax analysis using Flex and Bison, this implementation introduces a hash-based symbol table system composed of SymbolInfo, ScopeTable, and SymbolTable classes. Each scope maintains its own hash table with collision handling (typically chaining), and scopes are organized hierarchically to support nested blocks and function definitions. The parser embeds semantic actions within grammar rules to insert symbols during declarations, detect multiple declarations within the same scope, and identify undeclared variable usage by searching parent scopes. Scope entry and exit operations are triggered dynamically during parsing (e.g., on encountering { and }). This assignment effectively models real compiler behavior by enforcing scope rules, performing semantic checks, and maintaining symbol visibility across nested blocks, thereby implementing a functional semantic analysis phase of the compilation process.

ðŸ“˜ Assignment 3 â€“ Syntax-Directed Translation with Symbol Table Integration
Assignment 3 implements an advanced phase of compiler front-end construction by integrating syntax-directed translation with structured symbol table management using Flex and Bison. In this assignment, the lexical analyzer tokenizes the input source program into identifiers, keywords, literals, operators, and delimiters using regular expressions, while the parser validates syntactic correctness through a context-free grammar designed for a C-like language. Beyond pure parsing, semantic actions are embedded within grammar productions to perform symbol insertion, lookup, and validation during parse-time. A hash-based symbol table is implemented with separate ScopeTable and SymbolTable abstractions, supporting nested scopes and hierarchical lookup. Entering and exiting compound statements dynamically creates and destroys scope tables, closely simulating real compiler behavior. The system detects semantic errors such as multiple declarations within the same scope and usage of undeclared identifiers. This assignment demonstrates the transition from basic parsing to structured semantic processing within the compiler pipeline.

ðŸ“— Assignment 4 â€“ Semantic Analysis and Intermediate Code Preparation
Assignment 4 further extends the compiler front-end by incorporating deeper semantic analysis and structured program representation, preparing the system for intermediate code generation. Building on the lexical analyzer, parser, and hierarchical symbol table from previous assignments, this phase enhances semantic validation through type tracking, function parameter verification, return type consistency checking, and more refined error reporting. The parser integrates attribute handling within grammar rules to propagate type and contextual information across expressions and statements. Scope-sensitive symbol resolution ensures proper visibility and lifetime management of variables and functions. The architecture closely resembles that of a production compiler front-end, where syntax-directed definitions are used to enforce semantic correctness and prepare structured internal representations for later compilation stages. This assignment demonstrates a more complete semantic analysis phase and moves the project toward full compiler implementation.
